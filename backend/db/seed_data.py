"""One‑shot developer seed script for RecallGuard
================================================

This module inserts deterministic *sample* data so that a fresh dev
instance can be exercised end‑to‑end (API, alert generation, cron jobs).
It **must not** be run against production – it will happily create test
users and dummy recalls.

Features
--------
* Creates an **admin** account (`admin@example.com` / `admin123`).
* Spawns a handful of demo users, products and recalls via *Faker* so you
  have something to look at in the dashboard immediately.
* Idempotent: running multiple times will *update* existing rows rather
  than duplicating them.
* Usable as a **module** (`python -m backend.db.seed_data`) or via the
  convenience :pyfunc:`seed_demo_data` helper from tests.

Run
---
Just ensure you have a database up, environment variables loaded (see
``backend/utils/config.py``) and then execute:

>>> poetry run python -m backend.db.seed_data  # or `python -m ...` if not using Poetry
"""
from __future__ import annotations

import random
from datetime import datetime, timedelta, timezone

from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session, sessionmaker
from faker import Faker
from passlib.hash import bcrypt

from ..utils.config import get_settings  # type: ignore  # pylint: disable=import-error
from .models import Base, Product, Recall, User, product_recalls

fake = Faker()
settings = get_settings()

ENGINE = create_engine(settings.database_uri, echo=False, future=True)
SessionLocal = sessionmaker(bind=ENGINE, expire_on_commit=False, future=True)

# ---------------------------------------------------------------------------
# Helper functions
# ---------------------------------------------------------------------------

def _upsert_user(session: Session, email: str, *, is_admin: bool = False) -> User:
    """Insert user if not exists; return row."""
    stmt = select(User).where(User.email == email)
    user = session.scalars(stmt).first()
    if user:
        return user

    user = User(
        email=email,
        password_hash=bcrypt.hash("admin123" if is_admin else "password"),
        is_admin=is_admin,
        full_name=fake.name(),
        tier="pro" if is_admin else random.choice(["free", "pro"]),
        created_at=datetime.now(timezone.utc),
    )
    session.add(user)
    session.commit()
    return user


def _create_demo_products(session: Session, user: User, *, how_many: int = 3) -> None:
    """Attach a few random UPC products to *user*."""
    for _ in range(how_many):
        product = Product(
            owner_id=user.id,
            name=fake.catch_phrase(),
            upc=fake.ean(length=13),
            created_at=datetime.now(timezone.utc),
        )
        session.add(product)
    session.commit()


def _create_fake_recall(session: Session) -> Recall:
    """Insert a single dummy recall record (if not already present)."""
    recall_no = "FAKE‑%s" % datetime.now().strftime("%Y%m%d")
    stmt = select(Recall).where(Recall.external_id == recall_no)
    recall = session.scalars(stmt).first()
    if recall:
        return recall

    recall = Recall(
        external_id=recall_no,
        title="Potential Fire Hazard in Faux Product",
        description="This is *dummy* data generated by the seed script.",
        source="CPSC",
        published_at=datetime.now(timezone.utc) - timedelta(days=1),
        url="https://example.com/recalls/%s" % recall_no,
        severity="medium",
        last_updated=datetime.now(timezone.utc),
    )
    session.add(recall)
    session.commit()
    return recall


def _link_products_to_recall(session: Session, recall: Recall) -> None:
    """Randomly attach some products to *recall*."""
    products = session.scalars(select(Product)).all()
    if not products:
        return

    for product in random.sample(products, k=min(3, len(products))):
        # Association table insert (ignore duplicates).
        stmt = (
            select(product_recalls)
            .where(product_recalls.c.product_id == product.id)
            .where(product_recalls.c.recall_id == recall.id)
        )
        if session.execute(stmt).first():
            continue  # already linked
        session.execute(
            product_recalls.insert().values(product_id=product.id, recall_id=recall.id)
        )
    session.commit()


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def seed_demo_data(engine=ENGINE) -> None:  # noqa: D401 – imperative mood is fine here
    """Load predictable sample data into the database."""
    Base.metadata.create_all(bind=engine)  # ensure schema exists

    with SessionLocal() as session:
        admin = _upsert_user(session, "admin@example.com", is_admin=True)
        users = [admin] + [_upsert_user(session, f"user{i}@example.com") for i in range(1, 4)]

        for user in users:
            _create_demo_products(session, user)

        recall = _create_fake_recall(session)
        _link_products_to_recall(session, recall)

        session.commit()

    print("✅ Demo data seeded successfully.")


# ---------------------------------------------------------------------------
# CLI entry‑point
# ---------------------------------------------------------------------------

def main() -> None:  # pragma: no cover – simple wrapper
    """Run via `python -m backend.db.seed_data`."""
    seed_demo_data()


if __name__ == "__main__":
    main()
